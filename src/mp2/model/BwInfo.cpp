/**
* BWM API
* The ETSI MEC ISG MEC015 Bandwidth Management API described using OpenAPI
*
* OpenAPI spec version: 1.1.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "BwInfo.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

BwInfo::BwInfo()
{
    m_TimeStampIsSet = false;
    m_AppInsId = "";
    m_SessionFilterIsSet = false;
    m_FixedBWPriorityIsSet = false;
    m_FixedAllocation = "";
    
}

BwInfo::~BwInfo()
{
}

void BwInfo::validate()
{
    // TODO: implement validation
}

nlohmann::json BwInfo::toJson() const
{
    nlohmann::json val = nlohmann::json::object();

    if(m_TimeStampIsSet)
    {
        val["timeStamp"] = ModelBase::toJson(m_TimeStamp);
    }
    val["appInsId"] = ModelBase::toJson(m_AppInsId);
    val["requestType"] = ModelBase::toJson(m_RequestType);
    {
        nlohmann::json jsonArray;
        for( const auto& item : m_SessionFilter )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val["sessionFilter"] = jsonArray;
        } 
    }
    if(m_FixedBWPriorityIsSet)
    {
        val["fixedBWPriority"] = ModelBase::toJson(m_FixedBWPriority);
    }
    val["fixedAllocation"] = ModelBase::toJson(m_FixedAllocation);
    val["allocationDirection"] = ModelBase::toJson(m_AllocationDirection);
    

    return val;
}

void BwInfo::fromJson(const nlohmann::json& val)
{
    if(val.find("timeStamp") != val.end())
    {
        if(!val["timeStamp"].is_null())
        {
            TimeStamp newItem;
            newItem.fromJson(val["timeStamp"]);
            setTimeStamp( newItem );
        }
        
    }
    setAppInsId(val.at("appInsId"));
    {
        m_SessionFilter.clear();
        if(val.find("sessionFilter") != val.end())
        {
            for( const auto& item : val["sessionFilter"] )
            {
                
                if(item.is_null())
                {
                    m_SessionFilter.push_back( SessionFilterElement() );
                }
                else
                {
                    SessionFilterElement newItem;
                    newItem.fromJson(item);
                    m_SessionFilter.push_back( newItem );
                }
                
            }
        }
    }
    if(val.find("fixedBWPriority") != val.end())
    {
        if(!val["fixedBWPriority"].is_null())
        {
            FixedBWPriority newItem;
            newItem.fromJson(val["fixedBWPriority"]);
            setFixedBWPriority( newItem );
        }
        
    }
    setFixedAllocation(val.at("fixedAllocation"));
    
}


TimeStamp BwInfo::getTimeStamp() const
{
    return m_TimeStamp;
}
void BwInfo::setTimeStamp(TimeStamp const& value)
{
    m_TimeStamp = value;
    m_TimeStampIsSet = true;
}
bool BwInfo::timeStampIsSet() const
{
    return m_TimeStampIsSet;
}
void BwInfo::unsetTimeStamp()
{
    m_TimeStampIsSet = false;
}
std::string BwInfo::getAppInsId() const
{
    return m_AppInsId;
}
void BwInfo::setAppInsId(std::string const& value)
{
    m_AppInsId = value;
    
}
RequestType BwInfo::getRequestType() const
{
    return m_RequestType;
}
void BwInfo::setRequestType(RequestType const& value)
{
    m_RequestType = value;
    
}
std::vector<SessionFilterElement>& BwInfo::getSessionFilter()
{
    return m_SessionFilter;
}
bool BwInfo::sessionFilterIsSet() const
{
    return m_SessionFilterIsSet;
}
void BwInfo::unsetSessionFilter()
{
    m_SessionFilterIsSet = false;
}
FixedBWPriority BwInfo::getFixedBWPriority() const
{
    return m_FixedBWPriority;
}
void BwInfo::setFixedBWPriority(FixedBWPriority const& value)
{
    m_FixedBWPriority = value;
    m_FixedBWPriorityIsSet = true;
}
bool BwInfo::fixedBWPriorityIsSet() const
{
    return m_FixedBWPriorityIsSet;
}
void BwInfo::unsetFixedBWPriority()
{
    m_FixedBWPriorityIsSet = false;
}
std::string BwInfo::getFixedAllocation() const
{
    return m_FixedAllocation;
}
void BwInfo::setFixedAllocation(std::string const& value)
{
    m_FixedAllocation = value;
    
}
AllocationDirection BwInfo::getAllocationDirection() const
{
    return m_AllocationDirection;
}
void BwInfo::setAllocationDirection(AllocationDirection const& value)
{
    m_AllocationDirection = value;
    
}

}
}
}
}

