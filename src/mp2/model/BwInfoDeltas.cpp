/**
* BWM API
* The ETSI MEC ISG MEC015 Bandwidth Management API described using OpenAPI
*
* OpenAPI spec version: 1.1.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "BwInfoDeltas.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

BwInfoDeltas::BwInfoDeltas()
{
    m_AppInsId = "";
    m_AppInsIdIsSet = false;
    m_RequestTypeIsSet = false;
    m_SessionFilterIsSet = false;
    m_FixedBWPriorityIsSet = false;
    m_FixedAllocation = "";
    m_FixedAllocationIsSet = false;
    m_AllocationDirectionIsSet = false;
    
}

BwInfoDeltas::~BwInfoDeltas()
{
}

void BwInfoDeltas::validate()
{
    // TODO: implement validation
}

nlohmann::json BwInfoDeltas::toJson() const
{
    nlohmann::json val = nlohmann::json::object();

    if(m_AppInsIdIsSet)
    {
        val["appInsId"] = ModelBase::toJson(m_AppInsId);
    }
    if(m_RequestTypeIsSet)
    {
        val["requestType"] = ModelBase::toJson(m_RequestType);
    }
    {
        nlohmann::json jsonArray;
        for( const auto& item : m_SessionFilter )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            val["sessionFilter"] = jsonArray;
        } 
    }
    if(m_FixedBWPriorityIsSet)
    {
        val["fixedBWPriority"] = ModelBase::toJson(m_FixedBWPriority);
    }
    if(m_FixedAllocationIsSet)
    {
        val["fixedAllocation"] = ModelBase::toJson(m_FixedAllocation);
    }
    if(m_AllocationDirectionIsSet)
    {
        val["allocationDirection"] = ModelBase::toJson(m_AllocationDirection);
    }
    

    return val;
}

void BwInfoDeltas::fromJson(const nlohmann::json& val)
{
    if(val.find("appInsId") != val.end())
    {
        setAppInsId(val.at("appInsId"));
    }
    if(val.find("requestType") != val.end())
    {
        if(!val["requestType"].is_null())
        {
            RequestType newItem;
            newItem.fromJson(val["requestType"]);
            setRequestType( newItem );
        }
        
    }
    {
        m_SessionFilter.clear();
        if(val.find("sessionFilter") != val.end())
        {
            for( const auto& item : val["sessionFilter"] )
            {
                
                if(item.is_null())
                {
                    m_SessionFilter.push_back( SessionFilterElement() );
                }
                else
                {
                    SessionFilterElement newItem;
                    newItem.fromJson(item);
                    m_SessionFilter.push_back( newItem );
                }
                
            }
        }
    }
    if(val.find("fixedBWPriority") != val.end())
    {
        if(!val["fixedBWPriority"].is_null())
        {
            FixedBWPriority newItem;
            newItem.fromJson(val["fixedBWPriority"]);
            setFixedBWPriority( newItem );
        }
        
    }
    if(val.find("fixedAllocation") != val.end())
    {
        setFixedAllocation(val.at("fixedAllocation"));
    }
    if(val.find("allocationDirection") != val.end())
    {
        if(!val["allocationDirection"].is_null())
        {
            AllocationDirection newItem;
            newItem.fromJson(val["allocationDirection"]);
            setAllocationDirection( newItem );
        }
        
    }
    
}


std::string BwInfoDeltas::getAppInsId() const
{
    return m_AppInsId;
}
void BwInfoDeltas::setAppInsId(std::string const& value)
{
    m_AppInsId = value;
    m_AppInsIdIsSet = true;
}
bool BwInfoDeltas::appInsIdIsSet() const
{
    return m_AppInsIdIsSet;
}
void BwInfoDeltas::unsetAppInsId()
{
    m_AppInsIdIsSet = false;
}
RequestType BwInfoDeltas::getRequestType() const
{
    return m_RequestType;
}
void BwInfoDeltas::setRequestType(RequestType const& value)
{
    m_RequestType = value;
    m_RequestTypeIsSet = true;
}
bool BwInfoDeltas::requestTypeIsSet() const
{
    return m_RequestTypeIsSet;
}
void BwInfoDeltas::unsetRequestType()
{
    m_RequestTypeIsSet = false;
}
std::vector<SessionFilterElement>& BwInfoDeltas::getSessionFilter()
{
    return m_SessionFilter;
}
bool BwInfoDeltas::sessionFilterIsSet() const
{
    return m_SessionFilterIsSet;
}
void BwInfoDeltas::unsetSessionFilter()
{
    m_SessionFilterIsSet = false;
}
FixedBWPriority BwInfoDeltas::getFixedBWPriority() const
{
    return m_FixedBWPriority;
}
void BwInfoDeltas::setFixedBWPriority(FixedBWPriority const& value)
{
    m_FixedBWPriority = value;
    m_FixedBWPriorityIsSet = true;
}
bool BwInfoDeltas::fixedBWPriorityIsSet() const
{
    return m_FixedBWPriorityIsSet;
}
void BwInfoDeltas::unsetFixedBWPriority()
{
    m_FixedBWPriorityIsSet = false;
}
std::string BwInfoDeltas::getFixedAllocation() const
{
    return m_FixedAllocation;
}
void BwInfoDeltas::setFixedAllocation(std::string const& value)
{
    m_FixedAllocation = value;
    m_FixedAllocationIsSet = true;
}
bool BwInfoDeltas::fixedAllocationIsSet() const
{
    return m_FixedAllocationIsSet;
}
void BwInfoDeltas::unsetFixedAllocation()
{
    m_FixedAllocationIsSet = false;
}
AllocationDirection BwInfoDeltas::getAllocationDirection() const
{
    return m_AllocationDirection;
}
void BwInfoDeltas::setAllocationDirection(AllocationDirection const& value)
{
    m_AllocationDirection = value;
    m_AllocationDirectionIsSet = true;
}
bool BwInfoDeltas::allocationDirectionIsSet() const
{
    return m_AllocationDirectionIsSet;
}
void BwInfoDeltas::unsetAllocationDirection()
{
    m_AllocationDirectionIsSet = false;
}

}
}
}
}

