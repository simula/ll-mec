/**
* MP1 API
* The ETSI MEC ISG MEC012 Radio Network Information API, AND The ETSI MEC ISG MEC011 Application Enablement API
* AND some additional MEC APIs described using OpenAPI
*
* The version of the OpenAPI document: 1.1.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "ServicesApi.h"
#include "Helpers.h"
#include "spdlog.h"

namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::helpers;
using namespace llmec::mp1::model;

ServicesApi::ServicesApi(std::shared_ptr<Pistache::Rest::Router> rtr) {
    router = rtr;
};

void ServicesApi::init() {
    setupRoutes();
}

void ServicesApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/services", Routes::bind(&ServicesApi::services_get_handler, this));
    /**
     * @api {Get} /services Service availability query.
     * @apiName GetServices
     * @apiGroup MP1Services
     * @apiDescription  Either \"ser_instance_id\" or \"ser_name\" or \"ser_category_id\" shall be present.
     * @apiParam {String} ser_instance_id List of ser_instance_ids to query the availability of a list of ME service instances.
     * @apiParam {String} ser_category_id Category Id to query the availability of ME services.
     * @apiParam {String} ser_name Names of service to be queried.
     * @apiExample Example usage:
     *     curl -X GET -G http://127.0.0.1:8888/mp1/v1/services -d ser_instance_id="serviceId1" -d ser_category_id="RNI1" -d ser_name="PLMN Infomation"
     * @apiSuccessExample Success-Response:
     *     HTTP/1.1 200 OK
     *     [
     *     {"serCategory":{"href":"catRNI","id":"RNI1","name":"RNI","version":"version1"},"serInstanceId":"serviceId1","serName":"PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}
     *     ]
     *
     */

    Routes::Post(*router, base + "/services", Routes::bind(&ServicesApi::services_post_handler, this));
    /**
     * @api {Post} /services Create a service (new service registration).
     * @apiName PostServices
     * @apiGroup MP1Services
     * @apiParam {ServiceInfo} ServiceInfo (representing the general information of a ME service).
     * @apiExample Example usage:
     *     curl -X POST http://127.0.0.1:8888/mp1/v1/services -d  '{"serCategory":{"href":"catRNI","id":"RNI1","name":"RNI","version":"version1"},"serName":"PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}'
     *
     * @apiSuccessExample Success-Response:
     *     HTTP/1.1 200 OK
     *     
     *      {"serCategory":{"href":"catRNI","id":"RNI1","name":"RNI","version":"version1"},"serInstanceId":"serviceId1","serName":"PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}
     *
     */

    Routes::Get(*router, base + "/services/:serviceId", Routes::bind(&ServicesApi::services_service_id_get_handler, this));
    /**
     * @api {Get} /services/:id Get information of a service.
     * @apiName GetServiceID
     * @apiGroup MP1Services
     * @apiParam {String} serviceId Service Instance Id.
     * @apiExample Example usage:
     *     curl -X GET -G http://127.0.0.1:8888/mp1/v1/services/serviceId1
     * @apiSuccessExample Success-Response:
     *     HTTP/1.1 200 OK
     *
     *     {"serCategory":{"href":"catRNI","id":"RNI1","name":"RNI","version":"version1"},"serInstanceId":"serviceId1","serName":"PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}
     *
     *
     */

    Routes::Put(*router, base + "/services/:serviceId", Routes::bind(&ServicesApi::services_service_id_put_handler, this));
    /**
     * @api {Put} /services Update a ME service (service availability update).
     * @apiName PutServices
     * @apiGroup MP1Services
     * @apiParam {ServiceInfo} New ServiceInfo (representing the general information of a ME service).
     * @apiExample Example usage:
     *     curl -X PUT http://127.0.0.1:8888/mp1/v1/services/serviceId1 -d  '{"serCategory":{"href":"New Category","id":"RNI1","name":"RNI","version":"version1"},"serName":"New PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}'
     *
     * @apiSuccessExample Success-Response:
     *     HTTP/1.1 200 OK
     *     
     *     {"serCategory":{"href":"New Category","id":"RNI1","name":"RNI","version":"version1"},"serName":"New PLMN Information","serializer":"JSON","state":null,"transportInfo":{"description":"REST API","endpoint":{"addresses":[{"host":"127.0.0.1","port":8888}],"uris":["mp1/v1/queries/plmn_info"]},"id":"TransId1","name":"REST","protocol":"HTTP","security":{"oAuth2Info":{"grantTypes":["OAUTH2_CLIENT_CREDENTIALS"],"tokenEndpoint":"/mp1/v1/security/TokenEndPoint"}},"type":"REST_HTTP","version":"2.0"},"version":"ServiceVersion1"}
     *     
     */
   
    // Default handler, called when a route is not found
    //router->addCustomHandler(Routes::bind(&ServicesApi::mp1_api_default_handler, this));
}

void ServicesApi::services_get_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {

    // Getting the query params
    auto serInstanceIdQuery = request.query().get("ser_instance_id");
    Pistache::Optional<std::vector<std::string>> serInstanceId;
    if(!serInstanceIdQuery.isEmpty()){
        std::vector<std::string> value;
        if(fromStringValue(serInstanceIdQuery.get(), value)){
            serInstanceId = Pistache::Some(value);
        }
    }
    auto serNameQuery = request.query().get("ser_name");
    Pistache::Optional<std::vector<std::string>> serName;
    if(!serNameQuery.isEmpty()){
        std::vector<std::string> value;
        if(fromStringValue(serNameQuery.get(), value)){
            serName = Pistache::Some(value);
        }
    }
    auto serCategoryIdQuery = request.query().get("ser_category_id");
    Pistache::Optional<std::string> serCategoryId;
    if(!serCategoryIdQuery.isEmpty()){
        std::string value;
        if(fromStringValue(serCategoryIdQuery.get(), value)){
            serCategoryId = Pistache::Some(value);
        }
    }
    
    try {
      this->services_get(serInstanceId, serName, serCategoryId, response);
    } catch (nlohmann::detail::exception &e) {
        //send a 400 error
        response.send(Pistache::Http::Code::Bad_Request, e.what());
        return;
    } catch (std::exception &e) {
        //send a 500 error
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
        return;
    }

}
void ServicesApi::services_post_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {

    // Getting the body param
    
    ServiceInfo_Post serviceInfoPost;
    
    try {
      nlohmann::json::parse(request.body()).get_to(serviceInfoPost);
      this->services_post(serviceInfoPost, response);
    } catch (nlohmann::detail::exception &e) {
        //send a 400 error
        response.send(Pistache::Http::Code::Bad_Request, e.what());
        return;
    } catch (std::exception &e) {
        //send a 500 error
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
        return;
    }

}
void ServicesApi::services_service_id_get_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    // Getting the path params
    auto serviceId = request.param(":serviceId").as<std::string>();
    
    try {
      this->services_service_id_get(serviceId, response);
    } catch (nlohmann::detail::exception &e) {
        //send a 400 error
        response.send(Pistache::Http::Code::Bad_Request, e.what());
        return;
    } catch (std::exception &e) {
        //send a 500 error
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
        return;
    }

}
void ServicesApi::services_service_id_put_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    // Getting the path params
    auto serviceId = request.param(":serviceId").as<std::string>();
    
    // Getting the body param
    
    ServiceInfo serviceInfo;
    
    try {
      nlohmann::json::parse(request.body()).get_to(serviceInfo);
      this->services_service_id_put(serviceId, serviceInfo, response);
    } catch (nlohmann::detail::exception &e) {
        //send a 400 error
        response.send(Pistache::Http::Code::Bad_Request, e.what());
        return;
    } catch (std::exception &e) {
        //send a 500 error
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
        return;
    }

}


}
}
}

