/**
 * MP1 API
 * The ETSI MEC ISG MEC012 Radio Network Information API, AND The ETSI MEC ISG MEC011 Application Enablement API
 * AND some additional MEC APIs described using OpenAPI
 *
 * OpenAPI spec version: 1.1.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*!
  \file ServicesApiImpl.cpp
  \brief Implement MP1 Services API (ETSI MEC 011)
  \author Tien-Thinh NGUYEN
  \company Eurecom
  \email: thinhnt1983@gmail.com
*/

#include "ServicesApiImpl.h"
#include <fstream>
#include "spdlog.h"

namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::model;

ServicesApiImpl::ServicesApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr,
                                 llmec::mp1::rib::Rib& rib,
                                 llmec::event::subscription& ev)
: ServicesApi(rtr), m_rib(rib), m_event_sub(ev)
{ }

void ServicesApiImpl::services_get(const Pistache::Optional<std::vector<std::string>> &serInstanceId, const Pistache::Optional<std::vector<std::string>> &serName, const Pistache::Optional<std::string> &serCategoryId, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 Services API] Retrieve information about a list of meService resources");

	std::vector <std::string> serInstanceIDs;
	std::vector <std::string> serNames;
	std::string serCategoryIdStr;
	json serviceInfoList = {};
	//check the IDs of service is empty, if not get the corresponding services with these IDs
	if (!serInstanceId.isEmpty()){
		serInstanceIDs = serInstanceId.get();
		for (int i=0; i< serInstanceIDs.size(); i++){
			spdlog::get("ll-mec")->debug("[MP1 Services API] serInstanceId {}", serInstanceIDs[i]);
			json serviceInfoJson;
			ServiceInfo serviceInfo = m_rib.get_service_info_by_id(serInstanceIDs[i]);
			to_json(serviceInfoJson, serviceInfo);
			serviceInfoList.push_back(serviceInfoJson);

		}
		std::string resBody = serviceInfoList.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
		return;
	}

	//check the names of service is empty, if not get the corresponding services with these names
	if (!serName.isEmpty()){
		serNames = serName.get();
		for (int i=0; i< serNames.size(); i++){
			//spdlog::get("ll-mec")->debug("[MP1 Services API] serName {}", serNames[i]);
			json serviceInfoJson;
			ServiceInfo serviceInfo = m_rib.get_service_info_by_name(serNames[i]);
			to_json(serviceInfoJson, serviceInfo);
			serviceInfoList.push_back(serviceInfoJson);
		}
		std::string resBody = serviceInfoList.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
		return;
	}

	//check the category of service is empty, if not get the corresponding services with this category
	if (!serCategoryId.isEmpty()){
		serCategoryIdStr = serCategoryId.get();
		//spdlog::get("ll-mec")->debug("[MP1 Services API] serCategoryId {}", serCategoryIdStr);

		std::vector<ServiceInfo> serviceInfos = m_rib.get_service_info_by_category(serCategoryIdStr);

		for (int i=0; i< serviceInfos.size(); i++){
			json serviceInfoJson;
			to_json(serviceInfoJson, serviceInfos[i]);
			serviceInfoList.push_back(serviceInfoJson);
		}

		if (serviceInfoList.size() > 0){
			std::string resBody = serviceInfoList.dump();
			response.send(Pistache::Http::Code::Ok,resBody);
		} else{
			response.send(Pistache::Http::Code::Ok,"No service with this category!\n");
		}
		return;
	}
	response.send(Pistache::Http::Code::Ok, "Query parameters should be provided");
	return;

}

void ServicesApiImpl::services_post(const ServiceInfo_Post &serviceInfoPost, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Services API] Create a meService resource");

	ServiceInfo serviceInfo;

	std::string serInstanceId = "";
	serviceInfo.setSerInstanceId(serInstanceId);
	serviceInfo.setSerName(serviceInfoPost.getSerName());
	serviceInfo.setSerCategory(serviceInfoPost.getSerCategory());
	serviceInfo.setVersion(serviceInfoPost.getVersion());
	serviceInfo.setState(serviceInfoPost.getState());
	serviceInfo.setTransportInfo(serviceInfoPost.getTransportInfo());
	serviceInfo.setSerializer(serviceInfoPost.getSerializer());

	serInstanceId = m_rib.update_service_info(serInstanceId, serviceInfo);
	serviceInfo.setSerInstanceId(serInstanceId);
	std::string url = m_rib.get_mp1_server_addr() + ":" + std::to_string(m_rib.get_mp1_server_port()) + "/services/" + serInstanceId;
	response.headers().add<Pistache::Http::Header::Location>(url);
	json serviceInfoJson;
	to_json(serviceInfoJson, serviceInfo);
	response.send(Pistache::Http::Code::Ok, serviceInfoJson.dump());

	//notify the event for ServiceAvailabilityNotification
	dispatch_event(serviceInfoJson, llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_SERVICE_AVAILABILITY);
	return;

}

void ServicesApiImpl::services_service_id_get(const std::string &serviceId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Services API] Retrieve information about a meService resource with serviceId {}", serviceId);
	json serviceInfoJson;
	ServiceInfo serviceInfo = m_rib.get_service_info_by_id(serviceId);
	to_json(serviceInfoJson, serviceInfo);

	std::string resBody = serviceInfoJson.dump();
	response.send(Pistache::Http::Code::Ok,resBody);
	return;
}

void ServicesApiImpl::services_service_id_put(const std::string &serviceId, const ServiceInfo &serviceInfo, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 Services API] Update a meService resource with serviceId {}", serviceId);

	std::string serInstanceId = m_rib.update_service_info(serviceId, serviceInfo);
	json serviceInfoJson;
	to_json(serviceInfoJson, serviceInfo);
	response.send(Pistache::Http::Code::Ok, serviceInfoJson.dump());
}

void ServicesApiImpl::register_for_event(const std::shared_ptr<SubscriptionsApiImpl>& subscriptionsApiImpl, int event_type){
	spdlog::get("ll-mec")->info("[MP1 Services API] Register for Service's event");
	service_event_listeners_[event_type].push_back(subscriptionsApiImpl);
}


}
}
}

