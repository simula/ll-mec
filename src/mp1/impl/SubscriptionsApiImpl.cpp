/**
 * Mp1 API
 * The ETSI MEC ISG MEC011 Application Enablement API described using OpenAPI
 *
 * The version of the OpenAPI document: 1.1.1
 * Contact: cti_support@etsi.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*!
  \file SubscriptionsApiImpl.cpp
  \brief Implement MP1 Subscriptions API (ETSI MEC 011)
  \author Tien-Thinh NGUYEN
  \company Eurecom
  \email: thinhnt1983@gmail.com
*/

#include <iostream>
#include "SubscriptionsApiImpl.h"
#include "spdlog.h"
#include <curl/curl.h>
#define SUBSCRIPTION_CALLBACK_CURL_TIMEOUT_MS 100L
namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::model;

SubscriptionsApiImpl::SubscriptionsApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr,
                                           llmec::mp1::rib::Rib& rib,
                                           llmec::event::subscription &ev)
: SubscriptionsApi(rtr), m_rib(rib), m_event_sub(ev)
{ }

void SubscriptionsApiImpl::event_callback (json serviceInfo, llmec::mp1::rib::meMp1SubscriptionType evType){
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] call back function: send notification to the subscriber");

	//send notification to the corresponding subscriber
	nlohmann::json notificationInfos = m_rib.get_subscription_notification_info(serviceInfo, evType);

	int numApps = notificationInfos.size();
	for (int i = 0; i < numApps; i++){
		spdlog::get("ll-mec")->debug("[MP1 Subscriptions API] Event Callback, callbackref {} ", (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str());
		std::string notificationInfo = (notificationInfos.at(i)["notificationInfo"]).dump();
		spdlog::get("ll-mec")->debug("[MP1 Subscriptions API] Event Callback, NotificationInfo: {} ",notificationInfo );

		curl_global_init(CURL_GLOBAL_ALL);
		//send notification to MEC App
		struct curl_slist *headers = NULL;
		headers = curl_slist_append(headers, "Expect:");
		headers = curl_slist_append(headers, "Content-Type: application/json");
		headers = curl_slist_append(headers, "charsets: utf-8");
		CURL *curl = curl_easy_init();
		std::string url = (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str();

		if(curl) {
			CURLcode res;
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
			curl_easy_setopt(curl, CURLOPT_URL, url.c_str() );
			curl_easy_setopt(curl, CURLOPT_POST,1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, -1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, notificationInfo.c_str());
			curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, SUBSCRIPTION_CALLBACK_CURL_TIMEOUT_MS);

			// Response information.
			long httpCode(0);
			std::unique_ptr<std::string> httpData(new std::string());
			res = curl_easy_perform(curl);
			if(res != CURLE_OK)
				spdlog::get("ll-mec")->debug("[MP1 Subscriptions API] curl_easy_perform failed {} ",  curl_easy_strerror(res));

			//curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
			//spdlog::get("ll-mec")->debug("[MP1 Subscriptions API] Response from MEC App, HTTP code: {} ", httpCode);
			curl_easy_cleanup(curl);
		}
		curl_global_cleanup();
	}

	spdlog::get("ll-mec")->debug("[MP1 Subscriptions API] call back function {} ", notificationInfos.dump());
	return;

}

void SubscriptionsApiImpl::applications_subscription_delete(const std::string &appInstanceId, const std::string &subscriptionType, const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Delete a MeMp1Subscription (Unsubscribing from service availability event notifications)");
	llmec::mp1::rib::meMp1SubscriptionType subType;
	if (subscriptionType == "AppTerminationNotificationSubscription"){
		subType = llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_APPLICATION_TERMINATION;
	}else {
		subType = llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_SERVICE_AVAILABILITY;
	}
	m_rib.delete_me_mp1_subscription_info(appInstanceId,subType, subscriptionId);

	response.send(Pistache::Http::Code::No_Content);
}

void SubscriptionsApiImpl::applications_subscription_get(const std::string &appInstanceId, const std::string &subscriptionType, const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Get a MeMp1Subscription");
	json jsonData;
	llmec::mp1::rib::meMp1SubscriptionType subType;

	if (subscriptionType == "AppTerminationNotificationSubscription"){
		subType = llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_APPLICATION_TERMINATION;
	}else {
		subType = llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_SERVICE_AVAILABILITY;
	}

	jsonData = m_rib.get_me_mp1_subscription_info(appInstanceId, subType, subscriptionId);
	response.send(Pistache::Http::Code::Ok, jsonData.dump());
	return;
}

void SubscriptionsApiImpl::applications_subscriptions_get(const std::string &appInstanceId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Get a list of MeMp1Subscriptions");
	json jsonData;
	jsonData = m_rib.get_me_mp1_subscription_infos(appInstanceId);
	response.send(Pistache::Http::Code::Ok, jsonData.dump());
	return;
}

void SubscriptionsApiImpl::applications_subscriptions_post(const std::string &appInstanceId, const NotificationSubscription &body, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Create a new subscription");
	std::string subscriptionId;
	json jsonData;
	if (body.getSubscriptionType() == "AppTerminationNotificationSubscription"){
		AppTerminationNotificationSubscription appTerminationNotificationSubscription = dynamic_cast<const AppTerminationNotificationSubscription&> (body);
		std::string appId = appTerminationNotificationSubscription.getAppInstanceId();
		spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Create a new appTerminationNotificationSubscription {}", appId);
		//store subscription into a DB
		to_json(jsonData, appTerminationNotificationSubscription);
		subscriptionId = m_rib.update_me_mp1_subscription_info(appInstanceId, llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_APPLICATION_TERMINATION, jsonData);

	} else if (body.getSubscriptionType() == "SerAvailabilityNotificationSubscription"){
		spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Create a new SerAvailabilityNotificationSubscription");
		SerAvailabilityNotificationSubscription serAvailabilityNotificationSubscription = dynamic_cast<const SerAvailabilityNotificationSubscription &> (body) ;
		//store subscription into a DB
		to_json(jsonData, serAvailabilityNotificationSubscription);
		subscriptionId = m_rib.update_me_mp1_subscription_info(appInstanceId, llmec::mp1::rib::meMp1SubscriptionType::ME_MP1_SUBSCRIPTION_SERVICE_AVAILABILITY, jsonData);
	}

	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Create a new subscription with ID {}", subscriptionId);

	std::string url = m_rib.get_mp1_server_addr() + ":" + std::to_string(m_rib.get_mp1_server_port()) + "/applications/" + appInstanceId + "/subscriptions/" + body.getSubscriptionType() + "/" + subscriptionId;
	spdlog::get("ll-mec")->info("[MP1 Subscriptions API] Create a new subscription with URL {}", url);
	response.headers().add<Pistache::Http::Header::Location>(url);

	response.send(Pistache::Http::Code::Ok, jsonData.dump());
	return;
}

}
}
}

