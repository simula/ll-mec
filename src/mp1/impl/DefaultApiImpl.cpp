/**
* RNI API
* The ETSI MEC ISG MEC012 Radio Network Information API described using OpenAPI AND som additional MEC APIs
*
* OpenAPI spec version: 1.1.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "DefaultApiImpl.h"
#include <fstream>
#include <curl/curl.h>
#include "spdlog.h"
#include "ue_event.h"

namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::model;
#define DEFAULT_RIB_FILE  "src/mp1/inputs/mp1.json"
#define FLEXRAN_CURL_TIMEOUT_MS 100L
DefaultApiImpl::DefaultApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr, llmec::mp1::rib::Rib& rib)
    : DefaultApi(rtr), m_rib(rib)
    { }

void DefaultApiImpl::event_callback (std::string imsi, llmec::app::uplane::ueEventType evType){
	spdlog::get("ll-mec")->info("[MP1 API] Event Callback, UE IMSI: {}, event {} ", imsi, evType );

	//send notification to the corresponding Apps by using curl lib
	nlohmann::json notificationInfos = m_rib.get_notification_info(imsi,evType);
	int numApps = notificationInfos.size();
    for (int i = 0; i < numApps; i++){
    	spdlog::get("ll-mec")->debug("[MP1 API] Event Callback, App: {}, ref {} ", (notificationInfos.at(i)["appInsId"]).get<std::string>().c_str(), (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str());
    	std::string notificationInfo = (notificationInfos.at(i)["notificationInfo"]).dump();
    	spdlog::get("ll-mec")->debug("[MP1 API] Event Callback, NotificationInfo: {} ",notificationInfo );

		//send notification to MEC App
		struct curl_slist *headers = NULL;
		headers = curl_slist_append(headers, "Expect:");
		headers = curl_slist_append(headers, "Content-Type: application/json");
		headers = curl_slist_append(headers, "charsets: utf-8");
		CURL *curl = curl_easy_init();
		std::string url = (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str();

		if(curl) {
			CURLcode res;
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
			curl_easy_setopt(curl, CURLOPT_URL, url.c_str() );
			curl_easy_setopt(curl, CURLOPT_POST,1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, -1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, notificationInfo.c_str());

			// Response information.
			long httpCode(0);
			std::unique_ptr<std::string> httpData(new std::string());
			res = curl_easy_perform(curl);
			curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
			spdlog::get("ll-mec")->debug("[MP1 API] Response from MEC App, HTTP code: {} ", httpCode);
			curl_easy_cleanup(curl);
		}
    }

}


void DefaultApiImpl::ca_re_conf_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::ca_re_conf_subscription_subscriptions_post(const CaReConfSubscriptionPost &caReConfSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::ca_re_conf_subscription_subscriptions_put(const std::string &subscriptionId, const CaReConfSubscription &caReConfSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::ca_re_conf_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::cell_change_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::cell_change_subscriptions_post(const CellChangeSubscriptionPost &cellChangeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::cell_change_subscriptions_put(const std::string &subscriptionId, const CellChangeSubscription &cellChangeSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::cell_change_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::delete_mp1_traffic_all(const Mp1_traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::delete_mp1_traffic_imsi(const Mp1_traffic_imsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_rep_ue_report_subscriptions_put(const std::string &subscriptionId, const MeasRepUeSubscription &measRepUeSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_post(const MeasRepUeSubscriptionPost &measRepUeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_ta_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_ta_subscriptions_post(const MeasTaSubscriptionPost &measTaSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_ta_subscriptions_put(const std::string &subscriptionId, const MeasTaSubscription &measTaSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::meas_ta_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::plmn_info_get(const Pistache::Optional<std::vector<std::string>> &appInsId, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 API] Get PLMN info");

	if (appInsId.isEmpty()){
		spdlog::get("ll-mec")->debug("[MP1 API] AppInsId should be provided ");
		response.send(Pistache::Http::Code::Bad_Request, "[PLMN info] No information!\n");
	}

	//check whether AppInsId has permission to get PLMN info
	if (m_rib.get_app_permission(appInsId.get()[0], llmec::app::uplane::UE_QUERY_PLMN_INFO)){
		json jsonData = m_rib.get_plmn_info(appInsId.get());

		//if information is available
		if (!jsonData.empty()){
			Plmn plmn;
			Ecgi ecgi;
			try{
				plmn.fromJson(jsonData);
				ecgi.setPlmn(plmn);
				ecgi.fromJson(jsonData);
			} catch (json::exception& e){
				std::cout << "message: " << e.what() << '\n'
						<< "exception id: " << e.id << std::endl;
				response.send(Pistache::Http::Code::Not_Found, "[PLMN info] No information!\n");
			}
			std::string resBody = "PLMN info ";
			spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info,  MNC: {} ", ecgi.getPlmn().getMnc());
			spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info, MCC: {} ", ecgi.getPlmn().getMcc());
			std::vector<std::string> m_CellId = ecgi.getCellId();
			for (const std::string& str: m_CellId){
				spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info, Cell ID: {} ", str);
				resBody += "CellId " + str;
			}
			resBody += " MNC " +  ecgi.getPlmn().getMnc() + ", MCC " +  ecgi.getPlmn().getMcc() + "\n";
			response.send(Pistache::Http::Code::Ok, resBody);

		} else{//if there's no information, send response with Not_Found code to the app
			spdlog::get("ll-mec")->debug("[MP1 API] No PLMN info available ");
			response.send(Pistache::Http::Code::Not_Found, "[PLMN info] No information!\n");
		}
	} else{
		spdlog::get("ll-mec")->debug("[MP1 API] Don't have permission to get PLMN info ");
		response.send(Pistache::Http::Code::Unauthorized, "[PLMN info] not authorized to get this information!\n");
	}

}

void DefaultApiImpl::post_mp1_traffic_all(const Mp1_traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::post_mp1_traffic_imsi(const Mp1_traffic_imsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::post_platform(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_est_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get RabEstSubscription information\n");
	json jsonData = m_rib.get_app_subscription_info(subscriptionId,llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	if (!jsonData.empty()){
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No information for RabEstSubscriptoin with Id "+ subscriptionId + "\n";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}
}

void DefaultApiImpl::rab_est_subscription_subscriptions_post(const RabEstSubscriptionPost &rabEstSubscriptionPost, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 API] Post RabEstSubscription\n");

	//Store RabEstSubscription into a DB
	RabEstSubscription *rabEstSub = new RabEstSubscription();
	rabEstSub->setCallbackReference(rabEstSubscriptionPost.getCallbackReference());
	rabEstSub->setFilterCriteria(rabEstSubscriptionPost.getFilterCriteria());
	rabEstSub->setExpiryDeadline(rabEstSubscriptionPost.getExpiryDeadline());
    std::string appId = rabEstSubscriptionPost.getFilterCriteria().getAppInsId();
	std::string subscriptionId = appId;
	Link link;
	link.setSelf(m_rib.get_mp1_server_url() + base + "/" + subscriptionId);
	rabEstSub->setLinks(link);

	json jsonData = rabEstSub->toJson();
	m_rib.update_app_subscription_info(appId, llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT, jsonData);

	//send response
	std::string resBody = jsonData.dump();
	response.send(Pistache::Http::Code::Ok,resBody);
}
void DefaultApiImpl::rab_est_subscription_subscriptions_put(const std::string &subscriptionId, const RabEstSubscription &rabEstSubscription, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Put RabEstSubscription\n");

		//Store RabEstSubscription into a DB
		RabEstSubscription *rabEstSub = new RabEstSubscription();
		rabEstSub->setCallbackReference(rabEstSubscription.getCallbackReference());
		rabEstSub->setFilterCriteria(rabEstSubscription.getFilterCriteria());
		rabEstSub->setExpiryDeadline(rabEstSubscription.getExpiryDeadline());
	    //std::string appId = rabEstSubscription.getFilterCriteria().getAppInsId();
		Link link;
		link.setSelf(m_rib.get_mp1_server_url() + base + "/" + subscriptionId);
		rabEstSub->setLinks(link);

		json jsonData = rabEstSub->toJson();
		m_rib.update_app_subscription_info(subscriptionId, llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT, jsonData);

		//send response
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);

}
void DefaultApiImpl::rab_est_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Delete a RabEstSubscription with ID {}", subscriptionId );
	m_rib.delete_app_subscription_info(subscriptionId,llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	response.send(Pistache::Http::Code::Ok,"RabEstSubscription has been deleted!\n");
}
void DefaultApiImpl::rab_info_get(const Pistache::Optional<std::string> &appInsId, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<int32_t> &erabId, const Pistache::Optional<int32_t> &qci, const Pistache::Optional<int32_t> &erabGbrDl, const Pistache::Optional<int32_t> &erabGbrUl, const Pistache::Optional<int32_t> &erabMbrDl, const Pistache::Optional<int32_t> &erabMbrUl, Pistache::Http::ResponseWriter &response) {
    //To be done
	spdlog::get("ll-mec")->info("[MP1 API] Get RAB info\n");
	std::vector<std::string> cellIdMp1;
	std::vector<std::string> ueIpv4AddressMp1;
	std::vector<std::string> ueIpv6AddressMp1;
	std::vector<std::string> natedIpAddressMp1;
    // Pistache::Optional<std::vector<std::string>> &gtpTeid
    // Pistache::Optional<int32_t> &erabId
	//Pistache::Optional<int32_t> &qci
	//Pistache::Optional<int32_t> &erabGbrDl
	//Pistache::Optional<int32_t> &erabGbrUl
	//Pistache::Optional<int32_t> &erabMbrDl
	//Pistache::Optional<int32_t> &erabMbrUl

	if (!appInsId.isEmpty()){
		spdlog::get("ll-mec")->info("[MP1 API] Get RAB info, appInsId {}", appInsId.get());
		response.send(Pistache::Http::Code::Bad_Request, "[RAB info] AppInsId should be provided!\n");
	}

	//check authentication
    if (!m_rib.get_app_permission(appInsId.get(), llmec::app::uplane::UE_QUERY_PLMN_INFO)){
    	spdlog::get("ll-mec")->debug("[MP1 API] Don't have permission to get RAB info");
    	response.send(Pistache::Http::Code::Unauthorized, "[RAB info] not authorized to get this information!\n");
    }


	if (!cellId.isEmpty()) {
		cellIdMp1= cellId.get();

	}
	for (auto it = cellIdMp1.begin(); it != cellIdMp1.end(); ++it){
		spdlog::get("ll-mec")->info("[MP1 API] Get RAB info CellId {}", *it);
	}


	//response
	/*
    RabInfo:
      type: object
      required:
        - appInsId
        - requestId
      properties:
        timeStamp:
        properties:
          seconds:
             type: integer
            format: uint32
            description: The seconds part of the time. Time is defined as Unix-time since
              January 1, 1970, 00:00:00 UTC
            example: 1577836800
          nanoSeconds:
            type: integer
            format: uint32
            description: The nanoseconds part of the time. Time is defined as Unix-time since
              January 1, 1970, 00:00:00 UTC
            example: 0
        appInsId:
          type: string
          format: string
          description: Unique identifier for the mobile edge application instance
          example: "01"
        requestId:
          RequestId:
          type: string
          format: string
          description: Unique identifier allocated by the Mobile Edge application for the Information request.
          example: "01"
        cellUserInfo:
          type: array
          items:
            $ref: "#/components/schemas/CellUserInfo"
		*/

	json jsonData ;

	//generate RequestId
	std::string requestId ="01";

	//TimeStamp


	auto mime = Pistache::Http::Mime::MediaType::fromString("application/json");
	auto m1 = MIME(Application, Json);

	//response.headers().add<Header::ContentType>(MIME(Application, Json));
	//response.send(Pistache::Http::Code::Ok, m1.toString());
	//response.headers().add<Pistache::Header::ContentType>(MIME(Application, Json));

  //  auto one_header = Header::ContentType(MIME(Application, Json));
  //  auto sec_header = Header::Accept(); //there should me constructor from MIME
  //  sec_header.parseRaw("application/json", sizeof("application/json"));
  /// response.header<Http::Header::ContentType>(one_header)
   //.header<Http::Header::Accept>(sec_header)
   //.send();

	  response.send(Pistache::Http::Code::Ok, "Do some magic\n");



}
void DefaultApiImpl::rab_mod_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_mod_subscription_subscriptions_post(const RabModSubscriptionPost &rabModSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_mod_subscription_subscriptions_put(const std::string &subscriptionId, const RabModSubscription &rabModSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_mod_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_post(const RabRelSubscriptionPost &rabRelSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_put(const std::string &subscriptionId, const RabRelSubscription &rabRelSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::rab_rel_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::s1_bearer_info_get(const Pistache::Optional<std::vector<std::string>> &tempUeId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<int32_t>> &erabId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_post(const S1BearerSubscriptionPost &s1BearerSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_put(const std::string &subscriptionId, const S1BearerSubscription &s1BearerSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::s1_bearer_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_cc_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_cr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_get(Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get a list of all subscriptions");

	json jsonData = m_rib.get_app_subscription_list();
		if (!jsonData.empty()){
			//update links according to the subscription
			std::string link = (jsonData["links"]).get<std::string>().c_str();
	        link = link + base + "/subscriptions";
	        jsonData["links"] = link;
			std::string resBody = jsonData.dump();
			response.send(Pistache::Http::Code::Ok,resBody);
		} else{
			std::string resBody = "No subscription for RabEstSubscription";
			response.send(Pistache::Http::Code::Not_Found, resBody);
		}
}
void DefaultApiImpl::subscription_link_list_subscriptions_mr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_re_get(Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get a list of RabEstSubscriptions");
	json jsonData = m_rib.get_app_subscription_list(llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	if (!jsonData.empty()){
		//update links according to the subscription
		std::string link = (jsonData["links"]).get<std::string>().c_str();
        link = link + base + "/subscriptions/rab_est";
        jsonData["links"] = link;
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No subscription for RabEstSubscription";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}

}
void DefaultApiImpl::subscription_link_list_subscriptions_rm_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_rr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_s1_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_ta_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}
}
}
}

