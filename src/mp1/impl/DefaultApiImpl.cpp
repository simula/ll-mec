/**
* RNI API
* The ETSI MEC ISG MEC012 Radio Network Information API described using OpenAPI AND som additional MEC APIs
*
* OpenAPI spec version: 1.1.1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "DefaultApiImpl.h"
#include <fstream>
#include <curl/curl.h>
#include "spdlog.h"

namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::model;
#define DEFAULT_RIB_FILE  "src/mp1/inputs/mp1.json"

DefaultApiImpl::DefaultApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr, llmec::mp1::rib::Rib& rib)
    : DefaultApi(rtr), m_rib(rib)
    { }

void DefaultApiImpl::ca_re_conf_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::ca_re_conf_subscription_subscriptions_post(const CaReConfSubscriptionPost &caReConfSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::ca_re_conf_subscription_subscriptions_put(const std::string &subscriptionId, const CaReConfSubscription &caReConfSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::ca_re_conf_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::cell_change_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::cell_change_subscriptions_post(const CellChangeSubscriptionPost &cellChangeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::cell_change_subscriptions_put(const std::string &subscriptionId, const CellChangeSubscription &cellChangeSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::cell_change_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::delete_mp1_traffic_all(const Mp1_traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::delete_mp1_traffic_imsi(const Mp1_traffic_imsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_rep_ue_report_subscriptions_put(const std::string &subscriptionId, const MeasRepUeSubscription &measRepUeSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_post(const MeasRepUeSubscriptionPost &measRepUeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_rep_ue_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_ta_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_ta_subscriptions_post(const MeasTaSubscriptionPost &measTaSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_ta_subscriptions_put(const std::string &subscriptionId, const MeasTaSubscription &measTaSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::meas_ta_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::plmn_info_get(const Pistache::Optional<std::vector<std::string>> &appInsId, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 API] Get PLMN info");
	Plmn plmn;
	Ecgi ecgi;
	json jsonData;
	//query PLMN info from RNIS database
	//if test mode -> get infor from default json file
	if (m_mode.compare("test") == 0){
		spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info from a default Json file");
		jsonData =  GetJsonData(DEFAULT_RIB_FILE);
	} else { //get infor from FlexRAN
		spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info from FlexRAN controllers");
		for (auto i = m_flexRANControllers.begin(); i != m_flexRANControllers.end(); i++){
			jsonData  = GetJsonData((i)->first, (i)->second);
			if (!jsonData.empty()) break;
		}
	}

	//if information is available
	if (!jsonData.empty()){
		// plmn.fromJson(jsonData);
		//ecgi.setPlmn(plmn);
		//get Cell id from json file
		json eNB_config =  json (jsonData["eNB_config"]);
		json eNB =  (eNB_config.at(0))["eNB"];
		json cellConfig = eNB["cellConfig"];
		json UE = (eNB_config.at(0))["UE"];
		//json ueConfig = UE["ueConfig"];
		//json imsi = (ueConfig.at(0))["imsi"];
		ecgi.fromJson(cellConfig.at(0));

		spdlog::get("ll-mec")->debug("[MP1 API] MNC: {} ", ecgi.getPlmn().getMnc());
		spdlog::get("ll-mec")->debug("[MP1 API] MCC: {} ", ecgi.getPlmn().getMcc());
		std::vector<std::string> m_CellId = ecgi.getCellId();
		for (const std::string& str: m_CellId){
			spdlog::get("ll-mec")->debug("[MP1 API] Cell ID: {} ", str);
		}
		response.send(Pistache::Http::Code::Ok, "Do some magic with PLMN info\n");
	} else{//if there's no information, send response with Not_Found code to the app
		spdlog::get("ll-mec")->debug("[MP1 API] No PLMN info available ");
		response.send(Pistache::Http::Code::Not_Found, "[PLMN info] No information!\n");
	}
}

void DefaultApiImpl::post_mp1_traffic_all(const Mp1_traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::post_mp1_traffic_imsi(const Mp1_traffic_imsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::post_platform(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_est_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_est_subscription_subscriptions_post(const RabEstSubscriptionPost &rabEstSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_est_subscription_subscriptions_put(const std::string &subscriptionId, const RabEstSubscription &rabEstSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_est_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_info_get(const Pistache::Optional<std::string> &appInsId, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<int32_t> &erabId, const Pistache::Optional<int32_t> &qci, const Pistache::Optional<int32_t> &erabGbrDl, const Pistache::Optional<int32_t> &erabGbrUl, const Pistache::Optional<int32_t> &erabMbrDl, const Pistache::Optional<int32_t> &erabMbrUl, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_mod_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_mod_subscription_subscriptions_post(const RabModSubscriptionPost &rabModSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_mod_subscription_subscriptions_put(const std::string &subscriptionId, const RabModSubscription &rabModSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_mod_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_post(const RabRelSubscriptionPost &rabRelSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_rel_subscription_subscriptions_put(const std::string &subscriptionId, const RabRelSubscription &rabRelSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::rab_rel_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::s1_bearer_info_get(const Pistache::Optional<std::vector<std::string>> &tempUeId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<int32_t>> &erabId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_post(const S1BearerSubscriptionPost &s1BearerSubscriptionPost, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::s1_bearer_subscription_subscriptions_put(const std::string &subscriptionId, const S1BearerSubscription &s1BearerSubscription, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::s1_bearer_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_cc_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_cr_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_mr_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_re_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_rm_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_rr_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_s1_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}
void DefaultApiImpl::subscription_link_list_subscriptions_ta_get(Pistache::Http::ResponseWriter &response) {
    response.send(Pistache::Http::Code::Ok, "Do some magic\n");
}

json DefaultApiImpl::GetJsonData(std::string path)
{
	//load Json data from Json file to a json object
	std::ifstream in(path);
	//error when loading data.
	if(!in.is_open())
	{
		return nullptr;
	}
	json jsonData = json::parse(in);
	in.close();
	return jsonData;
}

json DefaultApiImpl::GetJsonData(std::string addr, int port)
{
	std::string readBuffer;
	curl_global_init(CURL_GLOBAL_DEFAULT);
	struct curl_slist *headers=NULL; // init to NULL is important
	headers = curl_slist_append(headers, "Accept: application/json");
	headers = curl_slist_append(headers, "Content-Type: application/json");
	headers = curl_slist_append(headers, "charsets: utf-8");

	CURL *curl = curl_easy_init();
	std::string url = addr + ":" + std::to_string(port) + "/stats";
	spdlog::get("ll-mec")->debug("[MP1 API] FlexRAN URL: {} ", url);

	if(curl) {
		CURLcode res;

		curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
		//curl_easy_setopt(curl, CURLOPT_URL, "http://127.0.0.1:9999/stats" );
		curl_easy_setopt(curl, CURLOPT_URL, url.c_str() );
		curl_easy_setopt(curl, CURLOPT_HTTPGET,1);
		curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 100L);

		// Response information.
		long httpCode(0);
		std::unique_ptr<std::string> httpData(new std::string());

		// Hook up data handling function.
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &callback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, httpData.get());
		res = curl_easy_perform(curl);
		curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
		spdlog::get("ll-mec")->debug("[MP1 API] Response from FlexRAN, HTTP code: {} ", httpCode);
		curl_easy_cleanup(curl);

		if (httpCode == 200)
		{
			spdlog::get("ll-mec")->debug("[MP1 API] Got successful response from FlexRAN, URL: {} ", url);
			spdlog::get("ll-mec")->debug("[MP1 API] RAN statistics from FlexRAN: {} ", *httpData.get());
			json jsonData = json::parse(*httpData.get() );
			return jsonData;
		}
		else
		{
			spdlog::get("ll-mec")->debug("[MP1 API] Couldn't GET response from FlexRAN, URL: {} ", url);
			return json(); //return an empty json
		}
	}

	return json(); //return an empty json

}

void DefaultApiImpl::setFlexRANControllers(std::vector<std::pair<std::string, int>> flexRANControllers){
	m_flexRANControllers = flexRANControllers;
}
void DefaultApiImpl::setMode(std::string mode){
	m_mode = mode;
}
/*
 * To read content of the response from FlexRAN controller
 */
static std::size_t callback(
		const char* in,
		std::size_t size,
		std::size_t num,
		std::string* out)
{
	const std::size_t totalBytes(size * num);
	out->append(in, totalBytes);
	return totalBytes;
}
}
}
}

