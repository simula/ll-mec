/**
 * MP1 API
 * The ETSI MEC ISG MEC012 Radio Network Information API, AND The ETSI MEC ISG MEC011 Application Enablement API
 * AND some additional MEC APIs described using OpenAPI
 *
 * OpenAPI spec version: 1.1.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*!
  \file Mp1ApiImpl.cpp
  \brief Implement RNI API (ETSI MEC 012)
  \author Tien-Thinh NGUYEN
  \company Eurecom
  \email: thinhnt1983@gmail.com
*/

#include "Mp1ApiImpl.h"
#include <fstream>
#include <curl/curl.h>
#include "spdlog.h"
#include "ue_event.h"

#define RNI_CALLBACK_CURL_TIMEOUT_MS 100L

namespace llmec {
namespace mp1 {
namespace api {

using namespace llmec::mp1::model;

Mp1ApiImpl::Mp1ApiImpl(std::shared_ptr<Pistache::Rest::Router> rtr, llmec::mp1::rib::Rib& rib)
: Mp1Api(rtr), m_rib(rib)
{ }

void Mp1ApiImpl::event_callback (std::string imsi, llmec::app::uplane::ueEventType evType){
	spdlog::get("ll-mec")->info("[MP1 API] Event Callback, UE IMSI: {}, event {} ", imsi, evType );

	//send notification to the corresponding Apps by using curl lib
	nlohmann::json notificationInfos = m_rib.get_notification_info(imsi,evType);
	int numApps = notificationInfos.size();
	for (int i = 0; i < numApps; i++){
		spdlog::get("ll-mec")->debug("[MP1 API] Event Callback, App: {}, ref {} ", (notificationInfos.at(i)["appInsId"]).get<std::string>().c_str(), (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str());
		std::string notificationInfo = (notificationInfos.at(i)["notificationInfo"]).dump();
		spdlog::get("ll-mec")->debug("[MP1 API] Event Callback, NotificationInfo: {} ",notificationInfo );

		//send notification to MEC App
		struct curl_slist *headers = NULL;
		headers = curl_slist_append(headers, "Expect:");
		headers = curl_slist_append(headers, "Content-Type: application/json");
		headers = curl_slist_append(headers, "charsets: utf-8");
		CURL *curl = curl_easy_init();
		std::string url = (notificationInfos.at(i)["callbackReference"]).get<std::string>().c_str();

		if(curl) {
			CURLcode res;
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
			curl_easy_setopt(curl, CURLOPT_URL, url.c_str() );
			curl_easy_setopt(curl, CURLOPT_POST,1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, -1L);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, notificationInfo.c_str());
			curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, RNI_CALLBACK_CURL_TIMEOUT_MS);

			// Response information.
			long httpCode(0);
			std::unique_ptr<std::string> httpData(new std::string());
			res = curl_easy_perform(curl);
			curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
			spdlog::get("ll-mec")->debug("[MP1 API] Response from MEC App, HTTP code: {} ", httpCode);
			curl_easy_cleanup(curl);
		}
	}

}


void Mp1ApiImpl::ca_re_conf_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::ca_re_conf_subscription_subscriptions_post(const CaReConfSubscriptionPost &caReConfSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::ca_re_conf_subscription_subscriptions_put(const std::string &subscriptionId, const CaReConfSubscription &caReConfSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::ca_re_conf_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::cell_change_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::cell_change_subscriptions_post(const CellChangeSubscriptionPost &cellChangeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::cell_change_subscriptions_put(const std::string &subscriptionId, const CellChangeSubscription &cellChangeSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::cell_change_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::delete_mp1_traffic_all(const Mp1Traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::delete_mp1_traffic_imsi(const Mp1TrafficImsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_rep_ue_report_subscriptions_put(const std::string &subscriptionId, const MeasRepUeSubscription &measRepUeSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}
void Mp1ApiImpl::meas_rep_ue_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_rep_ue_subscriptions_post(const MeasRepUeSubscriptionPost &measRepUeSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_rep_ue_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_ta_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_ta_subscriptions_post(const MeasTaSubscriptionPost &measTaSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_ta_subscriptions_put(const std::string &subscriptionId, const MeasTaSubscription &measTaSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::meas_ta_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented!\n");
}

void Mp1ApiImpl::plmn_info_get(const Pistache::Optional<std::vector<std::string>> &appInsId, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 API] Get PLMN info");

	if (appInsId.isEmpty()){
		spdlog::get("ll-mec")->debug("[MP1 API] AppInsId should be provided ");
		response.send(Pistache::Http::Code::Bad_Request, "[PLMN info] No information!\n");
		return;
	}
	json jsonResponse;

	//should check MEC 012: list of AppInsIds or AppInsId?
	for (int i = 0; i< appInsId.get().size(); i++){
		//check whether AppInsId has permission to get PLMN info
		if (m_rib.get_app_permission(appInsId.get()[i], llmec::app::uplane::UE_QUERY_PLMN_INFO)){
			json jsonData = m_rib.get_plmn_info(appInsId.get()[i]);
			spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info {}", jsonData.dump());

			//if information is available
			if (!jsonData.empty()){
				Ecgi ecgi;
				try{
					from_json(jsonData, ecgi);
				} catch (json::exception& e){
					spdlog::get("ll-mec")->warn("[MP1 API] message {}, exception id {} \n", e.what(), e.id);
					response.send(Pistache::Http::Code::Not_Found, "[PLMN info] No information!\n");
				}
				jsonResponse["appInId"] = appInsId.get()[i];
				jsonResponse["ecgi"]["plmn"]["mcc"] = ecgi.getPlmn().getMcc();
				jsonResponse["ecgi"]["plmn"]["mnc"] = ecgi.getPlmn().getMnc();
				jsonResponse["ecgi"]["cellId"] = ecgi.getCellId()[0];

				spdlog::get("ll-mec")->debug("[MP1 API] Get PLMN info MNC: {}, MCC: {}, cellId: {}", ecgi.getPlmn().getMnc(), ecgi.getPlmn().getMcc(), ecgi.getCellId()[0]);
				std::string resBody = jsonResponse.dump();

				response.send(Pistache::Http::Code::Ok, resBody);

			} else{//if there's no information, send response with Not_Found code to the app
				spdlog::get("ll-mec")->debug("[MP1 API] No PLMN info available ");
				response.send(Pistache::Http::Code::Not_Found, "[PLMN info] No information!\n");
			}
		} else{
			spdlog::get("ll-mec")->debug("[MP1 API] Don't have permission to get PLMN info ");
			response.send(Pistache::Http::Code::Unauthorized, "[PLMN info] not authorized to get this information!\n");
		}
	}



}

void Mp1ApiImpl::post_mp1_traffic_all(const Mp1Traffic &mp1Traffic, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::post_mp1_traffic_imsi(const Mp1TrafficImsi &mp1TrafficImsi, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::post_platform(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_est_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get RabEstSubscription information\n");
	json jsonData = m_rib.get_app_subscription_info(subscriptionId,llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	if (!jsonData.empty()){
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No information for RabEstSubscriptoin with Id "+ subscriptionId + "\n";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}
}

void Mp1ApiImpl::rab_est_subscription_subscriptions_post(const RabEstSubscriptionPost &rabEstSubscriptionPost, Pistache::Http::ResponseWriter &response) {

	spdlog::get("ll-mec")->info("[MP1 API] Post RabEstSubscription\n");

	//Store RabEstSubscription into a DB
	RabEstSubscription *rabEstSub = new RabEstSubscription();
	rabEstSub->setCallbackReference(rabEstSubscriptionPost.getCallbackReference());
	rabEstSub->setFilterCriteria(rabEstSubscriptionPost.getFilterCriteria());
	rabEstSub->setExpiryDeadline(rabEstSubscriptionPost.getExpiryDeadline());
	std::string appId = rabEstSubscriptionPost.getFilterCriteria().getAppInsId();
	std::string subscriptionId = appId;
	Link link;
	link.setSelf(m_rib.get_mp1_server_addr() + ":" + std::to_string(m_rib.get_mp1_server_port()) + base + "/rni/" + subscriptionId);
	rabEstSub->setLinks(link);

	json jsonData;
	to_json(jsonData, *rabEstSub);
	m_rib.update_app_subscription_info(appId, llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT, jsonData);

	//send response
	std::string resBody = jsonData.dump();
	response.send(Pistache::Http::Code::Ok,resBody);
}

void Mp1ApiImpl::rab_est_subscription_subscriptions_put(const std::string &subscriptionId, const RabEstSubscription &rabEstSubscription, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Put RabEstSubscription\n");

	//Store RabEstSubscription into a DB
	RabEstSubscription *rabEstSub = new RabEstSubscription();
	rabEstSub->setCallbackReference(rabEstSubscription.getCallbackReference());
	rabEstSub->setFilterCriteria(rabEstSubscription.getFilterCriteria());
	rabEstSub->setExpiryDeadline(rabEstSubscription.getExpiryDeadline());
	//std::string appId = rabEstSubscription.getFilterCriteria().getAppInsId();
	Link link;
	link.setSelf(m_rib.get_mp1_server_addr() + ":" + std::to_string(m_rib.get_mp1_server_port()) + base + "/" + subscriptionId);
	rabEstSub->setLinks(link);

	nlohmann::json jsonData;
	to_json(jsonData, *rabEstSub);

	json subInfo = m_rib.get_app_subscription_info(subscriptionId,llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	if (!subInfo.empty()){
		m_rib.update_app_subscription_info(subscriptionId, llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT, jsonData);
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No RabEstSubscription with Id "+ subscriptionId + "\n";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}

}

void Mp1ApiImpl::rab_est_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Delete a RabEstSubscription with ID {}", subscriptionId );
	m_rib.delete_app_subscription_info(subscriptionId,llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	response.send(Pistache::Http::Code::Ok,"RabEstSubscription has been deleted!\n");
}

void Mp1ApiImpl::rab_info_get(const Pistache::Optional<std::string> &appInsId, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<int32_t> &erabId, const Pistache::Optional<int32_t> &qci, const Pistache::Optional<int32_t> &erabGbrDl, const Pistache::Optional<int32_t> &erabGbrUl, const Pistache::Optional<int32_t> &erabMbrDl, const Pistache::Optional<int32_t> &erabMbrUl, Pistache::Http::ResponseWriter &response) {
	//To be done
	spdlog::get("ll-mec")->info("[MP1 API] Get RAB info\n");
	std::vector<std::string> cellIdMp1;
	std::vector<std::string> ueIpv4AddressMp1;
	std::vector<std::string> ueIpv6AddressMp1;
	std::vector<std::string> natedIpAddressMp1;
	//Pistache::Optional<std::vector<std::string>> &gtpTeid
	//Pistache::Optional<int32_t> &erabId
	//Pistache::Optional<int32_t> &qci
	//Pistache::Optional<int32_t> &erabGbrDl
	//Pistache::Optional<int32_t> &erabGbrUl
	//Pistache::Optional<int32_t> &erabMbrDl
	//Pistache::Optional<int32_t> &erabMbrUl

	if (!appInsId.isEmpty()){
		spdlog::get("ll-mec")->info("[MP1 API] Get RAB info, appInsId {}", appInsId.get());
		response.send(Pistache::Http::Code::Bad_Request, "[RAB info] AppInsId should be provided!\n");
	}

	//check authentication
	if (!m_rib.get_app_permission(appInsId.get(), llmec::app::uplane::UE_QUERY_PLMN_INFO)){
		spdlog::get("ll-mec")->debug("[MP1 API] Don't have permission to get RAB info");
		response.send(Pistache::Http::Code::Unauthorized, "[RAB info] not authorized to get this information!\n");
	}
/*

	if (!cellId.isEmpty()) {
		cellIdMp1= cellId.get();

	}
	for (auto it = cellIdMp1.begin(); it != cellIdMp1.end(); ++it){
		spdlog::get("ll-mec")->info("[MP1 API] Get RAB info CellId {}", *it);
	}

	json jsonData ;

	//generate RequestId
	std::string requestId ="01";

	//TimeStamp


	auto mime = Pistache::Http::Mime::MediaType::fromString("application/json");
	auto m1 = MIME(Application, Json);
*/
	response.send(Pistache::Http::Code::Ok, "Do some magic\n");

}

void Mp1ApiImpl::rab_mod_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_mod_subscription_subscriptions_post(const RabModSubscriptionPost &rabModSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_mod_subscription_subscriptions_put(const std::string &subscriptionId, const RabModSubscription &rabModSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_mod_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_rel_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_rel_subscription_subscriptions_post(const RabRelSubscriptionPost &rabRelSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_rel_subscription_subscriptions_put(const std::string &subscriptionId, const RabRelSubscription &rabRelSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::rab_rel_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::s1_bearer_info_get(const Pistache::Optional<std::vector<std::string>> &tempUeId, const Pistache::Optional<std::vector<std::string>> &ueIpv4Address, const Pistache::Optional<std::vector<std::string>> &ueIpv6Address, const Pistache::Optional<std::vector<std::string>> &natedIpAddress, const Pistache::Optional<std::vector<std::string>> &gtpTeid, const Pistache::Optional<std::vector<std::string>> &cellId, const Pistache::Optional<std::vector<int32_t>> &erabId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::s1_bearer_subscription_subscriptions_get(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::s1_bearer_subscription_subscriptions_post(const S1BearerSubscriptionPost &s1BearerSubscriptionPost, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::s1_bearer_subscription_subscriptions_put(const std::string &subscriptionId, const S1BearerSubscription &s1BearerSubscription, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::s1_bearer_subscriptions_subscr_id_delete(const std::string &subscriptionId, Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_cc_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_cr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_get(Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get a list of all subscriptions");

	json jsonData = m_rib.get_app_subscription_list();
	if (!jsonData.empty()){
		//update links according to the subscription
		std::string link = (jsonData["links"]).get<std::string>().c_str();
		link = link + base + "/subscriptions";
		jsonData["links"] = link;
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No subscription for RabEstSubscription";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}
}

void Mp1ApiImpl::subscription_link_list_subscriptions_mr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_re_get(Pistache::Http::ResponseWriter &response) {
	spdlog::get("ll-mec")->info("[MP1 API] Get a list of RabEstSubscriptions");
	json jsonData = m_rib.get_app_subscription_list(llmec::app::uplane::UE_EVENT_RAB_ESTABLISHMENT);
	if (!jsonData.empty()){
		//update links according to the subscription
		std::string link = (jsonData["links"]).get<std::string>().c_str();
		link = link + base + "/subscriptions/rab_est";
		jsonData["links"] = link;
		std::string resBody = jsonData.dump();
		response.send(Pistache::Http::Code::Ok,resBody);
	} else{
		std::string resBody = "No subscription for RabEstSubscription";
		response.send(Pistache::Http::Code::Not_Found, resBody);
	}

}

void Mp1ApiImpl::subscription_link_list_subscriptions_rm_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_rr_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_s1_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}

void Mp1ApiImpl::subscription_link_list_subscriptions_ta_get(Pistache::Http::ResponseWriter &response) {
	response.send(Pistache::Http::Code::Ok, "This API has not been implemented (will be available soon)!\n");
}


}
}
}

